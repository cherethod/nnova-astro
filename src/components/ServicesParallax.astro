---
// Props del componente
export interface Props {
  services?: Array<{
    title: string;
    description: string;
    image: string;
    buttonText?: string;
    buttonLink?: string;
  }>;
}

const { 
  services = [
    {
      title: "Instalación de Drywall",
      description: "Transformamos espacios con instalaciones de drywall de alta calidad, ofreciendo soluciones versátiles y duraderas para cualquier proyecto de construcción o remodelación.",
      image: "https://nnovadesigns.com/img/services/servicios-iluminacion-indirecta-drywall.webp",
      buttonText: "Ver Servicio",
      buttonLink: "#servicio-drywall"
    },
    {
      title: "Aislamiento Acústico",
      description: "Creamos ambientes más confortables y silenciosos con nuestras soluciones de aislamiento acústico, perfectas para oficinas, estudios y espacios residenciales.",
      image: "https://nnovadesigns.com/img/services/servicios-iluminacion-indirecta-drywall.webp",
      buttonText: "Conocer Más",
      buttonLink: "#servicio-acustico"
    },
    {
      title: "Diseño de Interiores",
      description: "Diseñamos espacios únicos que reflejan tu personalidad y necesidades, combinando funcionalidad y estética para crear ambientes excepcionales.",
      image: "https://nnovadesigns.com/img/services/servicios-iluminacion-indirecta-drywall.webp",
      buttonText: "Explorar",
      buttonLink: "#servicio-diseno"
    }
  ]
} = Astro.props;
---

<section class="services-parallax py-20 lg:py-32 bg-gray-50 overflow-hidden">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
    <!-- Título de la sección -->
    <div class="text-center mb-16 lg:mb-24">
      <h2 class="text-4xl md:text-5xl lg:text-6xl font-bold text-gray-900 mb-6">
        Nuestros Servicios
      </h2>
      <p class="text-xl md:text-2xl text-gray-600 max-w-3xl mx-auto">
        Soluciones integrales para transformar tus espacios con la más alta calidad y profesionalismo
      </p>
    </div>

    <!-- Servicios -->
    <div class="space-y-32 lg:space-y-48">
      {services.map((service, index) => (
        <div 
          class={`service-item flex flex-col lg:flex-row items-center gap-8 lg:gap-16 ${
            index % 2 === 1 ? 'lg:flex-row-reverse' : ''
          }`}
          data-service-index={index}
        >
          <!-- Imagen -->
          <div class="w-full lg:w-1/2 relative">
            <div class="service-image-container relative overflow-hidden rounded-2xl shadow-2xl">
              <img 
                src={service.image} 
                alt={service.title}
                class="service-image w-full h-[400px] md:h-[500px] lg:h-[600px] object-cover transition-transform duration-700"
                loading="lazy"
              />
              <div class="absolute inset-0 bg-gradient-to-t from-black/20 to-transparent"></div>
            </div>
          </div>

          <!-- Contenido -->
          <div class="w-full lg:w-1/2 service-content">
            <div class="max-w-xl">
              <h3 class="text-3xl md:text-4xl lg:text-5xl font-bold text-gray-900 mb-6">
                {service.title}
              </h3>
              <p class="text-lg md:text-xl text-gray-600 mb-8 leading-relaxed">
                {service.description}
              </p>
              <a 
                href={service.buttonLink || '#'} 
                class="inline-flex items-center px-8 py-4 bg-gradient-to-r from-primary-600 to-primary-700 text-white font-semibold rounded-xl shadow-lg hover:shadow-xl transform hover:-translate-y-1 transition-all duration-300 hover:from-primary-700 hover:to-primary-800"
              >
                {service.buttonText || 'Ver Más'}
                <svg class="ml-2 w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8l4 4m0 0l-4 4m4-4H3" />
                </svg>
              </a>
            </div>
          </div>
        </div>
      ))}
    </div>
  </div>
</section>

<style>
  .service-item {
    opacity: 0;
    transform: translateY(60px);
    transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  .service-item.animate-in {
    opacity: 1;
    transform: translateY(0);
  }

  .service-image {
    transform: scale(1.1);
    transition: transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  .service-item.animate-in .service-image {
    transform: scale(1);
  }

  .service-content {
    transform: translateX(60px);
    opacity: 0;
    transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.2s;
  }

  .service-item.animate-in .service-content {
    transform: translateX(0);
    opacity: 1;
  }

  /* Para elementos que van por la izquierda */
  .service-item:nth-child(even) .service-content {
    transform: translateX(-60px);
  }

  .service-item:nth-child(even).animate-in .service-content {
    transform: translateX(0);
  }

  /* Parallax effect */
  .service-image-container {
    transition: transform 0.1s linear;
  }

  /* Responsive adjustments */
  @media (max-width: 1024px) {
    .service-content {
      transform: translateY(30px);
    }
    
    .service-item.animate-in .service-content {
      transform: translateY(0);
    }
    
    .service-item:nth-child(even) .service-content {
      transform: translateY(30px);
    }
    
    .service-item:nth-child(even).animate-in .service-content {
      transform: translateY(0);
    }
  }
</style>

<script>
  class ServicesParallax {
    constructor() {
      this.serviceItems = document.querySelectorAll('.service-item');
      this.imageContainers = document.querySelectorAll('.service-image-container');
      this.isInitialized = false;
      
      this.init();
    }

    init() {
      // Configurar el Intersection Observer para las animaciones
      this.setupIntersectionObserver();
      
      // Configurar el parallax scroll
      this.setupParallaxScroll();
      
      this.isInitialized = true;
    }

    setupIntersectionObserver() {
      const observerOptions = {
        root: null,
        rootMargin: '-10% 0px -20% 0px',
        threshold: 0.1
      };

      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('animate-in');
          }
        });
      }, observerOptions);

      this.serviceItems.forEach(item => {
        observer.observe(item);
      });
    }

    setupParallaxScroll() {
      let ticking = false;

      const updateParallax = () => {
        const scrollY = window.pageYOffset;
        
        this.imageContainers.forEach((container, index) => {
          const rect = container.getBoundingClientRect();
          const containerTop = rect.top + scrollY;
          const containerHeight = rect.height;
          const windowHeight = window.innerHeight;
          
          // Calcular si el elemento está en el viewport
          if (rect.top < windowHeight && rect.bottom > 0) {
            // Calcular el factor de parallax basado en la posición del scroll
            const scrollProgress = (scrollY + windowHeight - containerTop) / (windowHeight + containerHeight);
            const parallaxOffset = (scrollProgress - 0.5) * 50; // Ajusta el multiplicador para más/menos efecto
            
            container.style.transform = `translateY(${parallaxOffset}px)`;
          }
        });
        
        ticking = false;
      };

      const requestParallaxUpdate = () => {
        if (!ticking) {
          requestAnimationFrame(updateParallax);
          ticking = true;
        }
      };

      // Event listener para el scroll con throttling
      window.addEventListener('scroll', requestParallaxUpdate, { passive: true });
      
      // Llamar una vez al inicio
      updateParallax();
    }

    destroy() {
      // Limpiar event listeners si es necesario
      window.removeEventListener('scroll', this.requestParallaxUpdate);
    }
  }

  // Inicializar cuando el DOM esté listo
  document.addEventListener('DOMContentLoaded', () => {
    new ServicesParallax();
  });

  // Limpiar al cambiar de página (específico de Astro)
  document.addEventListener('astro:before-preparation', () => {
    const parallaxInstance = window.servicesParallaxInstance;
    if (parallaxInstance && parallaxInstance.destroy) {
      parallaxInstance.destroy();
    }
  });
</script>
